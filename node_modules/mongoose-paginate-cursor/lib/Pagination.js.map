{"version":3,"sources":["../src/Pagination.js"],"names":["globalSchema","debug","debugData","schema","name","paginate","sinceId","maxId","limit","page","select","where","keyID","keyOrder","reverse","map","filter","lsThanE","lsThan","gsThan","queryParams","findOneQuery","objFound","findOne","keyOrderSince","keyOrderMax","sort","equalKeys","calculateNewQuery","queryEnd","middleRangeQueryOrder","queryOrs","queryAnds","_","isNil","equalOrderSince","querySinceId","sinceIdExclusive","set","push","equalOrderMax","queryMaxId","isEmpty","queryOrderMiddle","length","$or","$and","JSON","stringify","findWithLimit","limitFind","pageFind","queryObj","query","find","skip","objectsFirstFound","exec","mappedObjects","Promise","resolve","objects","limitObjects","parseInt","objToFilter","objectsFoundFirst","iterationCount","objectsFiltered","concat","lastIndex","lastOrderValue","get","lastOrderID","nextCursor","lastItem","findNextWithSameOrder","nextObject","objectReturn","statics"],"mappings":"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","file":"Pagination.js","sourcesContent":["/**\n * Created by david on 9/22/16.\n */\nimport _debug from 'debug';\nimport _ from 'lodash';\nimport Promise from 'bluebird';\n\nconst debug = _debug('mpaginate:info');\nconst debugData = _debug('mpaginate:data');\n\nexport default function globalSchema(schema, { name } = {}) {\n  const paginate = async function paginate({\n    sinceId,\n    maxId,\n    limit = 1,\n    page = 0,\n    select,\n    where = {},\n    keyID = '_id',\n    keyOrder = '_id',\n    reverse = false,\n    map,\n    filter,\n  } = {}) {\n\n    debug('will paginate', {\n      sinceId,\n      maxId,\n      limit,\n      select,\n      where,\n      keyID,\n      keyOrder,\n      reverse,\n      map,\n      filter,\n    });\n    const lsThanE = reverse ? '$gte' : '$lte';\n    const lsThan = reverse ? '$gt' : '$lt';\n    const gsThan = reverse ? '$lt' : '$gt';\n    const queryParams = {\n      sinceId,\n      maxId,\n    };\n\n\n    if (sinceId) {\n      const findOneQuery = {};\n      findOneQuery[keyID] = sinceId;\n      // ejm: { count: 33 }\n      const objFound = await this.findOne(findOneQuery);\n      if (objFound) {\n        debug('found on sinceId', objFound);\n        queryParams.keyOrderSince = objFound[keyOrder];\n      }\n    }\n\n    if (maxId) {\n      const findOneQuery = {};\n      findOneQuery[keyID] = maxId;\n      const objFound = await this.findOne(findOneQuery);\n      if (objFound) {\n        debug('found on maxId', objFound);\n        // find where _id is greater than the one on maxId\n        queryParams.keyOrderMax = objFound[keyOrder];\n      }\n    }\n    // queryDocumentsGeneral.$or = findOrs;\n\n    const sort = {};\n    sort[keyOrder] = reverse ? 1 : -1;\n    if (keyID !== keyOrder) {\n      sort[keyID] = reverse ? 1 : -1;\n    }\n    const equalKeys = (keyID === keyOrder);\n    const calculateNewQuery = () => {\n      const queryEnd = {};\n      // ejm: { $lt: 55, $gt: 55 }\n      const middleRangeQueryOrder = {};\n      const queryOrs = [];\n      const queryAnds = [];\n      const keyOrderMax = queryParams.keyOrderMax;\n      const keyOrderSince = queryParams.keyOrderSince;\n\n      if (!_.isNil(keyOrderSince)) {\n        // high range\n        // ejm: { id: {$lt: sinceId}, count: 55 }\n        const equalOrderSince = {};\n        // ejm: {$lt: sinceId}\n        const querySinceId = {};\n        querySinceId[lsThanE] = queryParams.sinceId;\n        if (!_.isNil(queryParams.sinceIdExclusive)) {\n          querySinceId[lsThan] = queryParams.sinceIdExclusive;\n        }\n        equalOrderSince[keyID] = querySinceId;\n        if (!equalKeys) {\n          _.set(equalOrderSince, keyOrder, keyOrderSince);\n          // equalOrderSince[keyOrder] = keyOrderSince;\n        }\n        debug('calculateNewQuery querySinceId', querySinceId);\n        if (keyOrderMax === keyOrderSince || equalKeys) {\n          queryAnds.push(equalOrderSince);\n        } else {\n          queryOrs.push(equalOrderSince);\n          // middle range\n          // ejm: {$lt: 55}\n          middleRangeQueryOrder[lsThan] = queryParams.keyOrderSince;\n        }\n      }\n      if (!_.isNil(keyOrderMax)) {\n        // ejm: { id: {$gt: sinceId}, count: 33 }\n        const equalOrderMax = {};\n        // ejm: {$lt: sinceId}\n        const queryMaxId = {};\n        queryMaxId[gsThan] = queryParams.maxId;\n        equalOrderMax[keyID] = queryMaxId;\n        if (!equalKeys) {\n          _.set(equalOrderMax, keyOrder, keyOrderMax);\n          // equalOrderMax[keyOrder] = keyOrderMax;\n        }\n        debug('calculateNewQuery queryMaxId', queryMaxId);\n        if (keyOrderMax === keyOrderSince || equalKeys) {\n          queryAnds.push(equalOrderMax);\n        } else {\n          queryOrs.push(equalOrderMax);\n          // middle range\n          // ejm: {$gt: 33 }\n          middleRangeQueryOrder[gsThan] = queryParams.keyOrderMax;\n        }\n      }\n      if (!_.isEmpty(middleRangeQueryOrder)) {\n        const queryOrderMiddle = {};\n        _.set(queryOrderMiddle, keyOrder, middleRangeQueryOrder);\n        // queryOrderMiddle[keyOrder] = middleRangeQueryOrder;\n        queryOrs.push(queryOrderMiddle);\n      }\n      if (queryOrs.length) {\n        queryAnds.push({\n          $or: queryOrs,\n        });\n      }\n      if (!_.isEmpty(where)) {\n        queryAnds.push(where);\n      }\n      if (queryAnds.length) {\n        queryEnd.$and = queryAnds;\n      }\n      debug('calculateNewQuery', JSON.stringify(queryEnd));\n      return queryEnd;\n    };\n    /**\n     * find with query and map it\n     * @param limitFind\n     * @return {*}\n     */\n    const findWithLimit = async (limitFind, pageFind) => {\n      const queryObj = calculateNewQuery();\n      debug('will findWithLimit', { where: queryObj, limit: limitFind, select });\n      let query = this.find(queryObj, select)\n        .sort(sort);\n      if (limitFind) {\n        query = query.limit(limitFind);\n        if (pageFind) {\n          query = query.skip(limitFind * pageFind);\n        }\n      }\n\n      const objectsFirstFound = await query.exec();\n      let mappedObjects;\n      // map the objects if there is a map\n      if (map) {\n        mappedObjects = await Promise.resolve(objectsFirstFound).map(map);\n      } else {\n        mappedObjects = objectsFirstFound;\n      }\n      return mappedObjects;\n    };\n\n\n    let objects = [];\n    let limitObjects = parseInt(limit, 10) || 1;\n\n    // FILTER\n    if (filter) {\n      let objToFilter = await findWithLimit(limit, page);\n      const objectsFoundFirst = objToFilter.length;\n      if (objectsFoundFirst < limitObjects) {\n        limitObjects = objectsFoundFirst;\n      }\n      let iterationCount = 0;\n      // loop once to apply the filter\n      do {\n        debugData(`iteration ${iterationCount}, data`, objToFilter);\n        // filter objects found that has not been filtered\n        const objectsFiltered = await Promise.resolve(objToFilter).filter(filter);\n\n        debugData(`iteration ${iterationCount}, data filtered`, objectsFiltered);\n        // add filtered objects to final array\n        objects = objects.concat(objectsFiltered);\n\n\n        // set the limit to get the missing objects filtered\n        limitObjects -= objectsFiltered.length;\n        debug(`filtered ${limitObjects} element(s)`);\n        if (limitObjects <= 0) {\n          break;\n        }\n        const lastIndex = objToFilter.length - 1;\n        const lastOrderValue = _.get(objToFilter[lastIndex], keyOrder);\n        const lastOrderID = objToFilter[lastIndex][keyID];\n        // set the cursor to search AFTER the last found\n        queryParams.sinceIdExclusive = lastOrderID;\n        queryParams.keyOrderSince = lastOrderValue;\n        // get the new objects from the model list\n        objToFilter = await findWithLimit(limitObjects);\n\n        debug(`${objToFilter.length} element(s) to replace with filter`);\n        // while the limit has items to get and the found objects to fetch and filter\n        iterationCount += 1;\n      } while (limitObjects > 0 && objToFilter.length > 0);\n    } else {\n      // if there is no filter set objects found\n      objects = await findWithLimit(limit, page);\n    }\n\n    let nextCursor;\n\n    if (objects.length) {\n      debug('objects has length', objects.length);\n      const lastItem = objects[objects.length - 1];\n      queryParams.sinceId = lastItem[keyID];\n      queryParams.keyOrderSince = _.get(lastItem, keyOrder);\n      const findNextWithSameOrder = calculateNewQuery();\n\n      debug('find nextCursor with', { where: findNextWithSameOrder, select: keyID });\n      const nextObject = await this\n          .findOne(findNextWithSameOrder, keyID)\n          .sort(sort).skip(1);\n\n\n      debug('found on nextObject', nextObject);\n      if (!_.isNil(nextObject)) {\n        nextCursor = nextObject[keyID];\n        debug('nextCursor found', nextCursor);\n      } else {\n        debug('nextCursor no found');\n      }\n    }\n\n    const objectReturn = {\n      objects,\n      nextCursor,\n    };\n    return objectReturn;\n  };\n\n  if (name) {\n    schema.statics[name] = paginate;\n  } else {\n    schema.statics.paginate = paginate;\n  }\n}\n\n"]}