'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = globalSchema;

var _debug2 = require('debug');

var _debug3 = _interopRequireDefault(_debug2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  * Created by david on 9/22/16.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  */


const debug = (0, _debug3.default)('mpaginate:info');
const debugData = (0, _debug3.default)('mpaginate:data');

function globalSchema(schema) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  let name = _ref.name;

  const paginate = (() => {
    var _ref2 = _asyncToGenerator(function* () {
      var _this = this;

      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      let sinceId = _ref3.sinceId,
          maxId = _ref3.maxId;
      var _ref3$limit = _ref3.limit;
      let limit = _ref3$limit === undefined ? 1 : _ref3$limit;
      var _ref3$page = _ref3.page;
      let page = _ref3$page === undefined ? 0 : _ref3$page,
          select = _ref3.select;
      var _ref3$where = _ref3.where;
      let where = _ref3$where === undefined ? {} : _ref3$where;
      var _ref3$keyID = _ref3.keyID;
      let keyID = _ref3$keyID === undefined ? '_id' : _ref3$keyID;
      var _ref3$keyOrder = _ref3.keyOrder;
      let keyOrder = _ref3$keyOrder === undefined ? '_id' : _ref3$keyOrder;
      var _ref3$reverse = _ref3.reverse;
      let reverse = _ref3$reverse === undefined ? false : _ref3$reverse,
          map = _ref3.map,
          filter = _ref3.filter;


      debug('will paginate', {
        sinceId: sinceId,
        maxId: maxId,
        limit: limit,
        select: select,
        where: where,
        keyID: keyID,
        keyOrder: keyOrder,
        reverse: reverse,
        map: map,
        filter: filter
      });
      const lsThanE = reverse ? '$gte' : '$lte';
      const lsThan = reverse ? '$gt' : '$lt';
      const gsThan = reverse ? '$lt' : '$gt';
      const queryParams = {
        sinceId: sinceId,
        maxId: maxId
      };

      if (sinceId) {
        const findOneQuery = {};
        findOneQuery[keyID] = sinceId;
        // ejm: { count: 33 }
        const objFound = yield this.findOne(findOneQuery);
        if (objFound) {
          debug('found on sinceId', objFound);
          queryParams.keyOrderSince = objFound[keyOrder];
        }
      }

      if (maxId) {
        const findOneQuery = {};
        findOneQuery[keyID] = maxId;
        const objFound = yield this.findOne(findOneQuery);
        if (objFound) {
          debug('found on maxId', objFound);
          // find where _id is greater than the one on maxId
          queryParams.keyOrderMax = objFound[keyOrder];
        }
      }
      // queryDocumentsGeneral.$or = findOrs;

      const sort = {};
      sort[keyOrder] = reverse ? 1 : -1;
      if (keyID !== keyOrder) {
        sort[keyID] = reverse ? 1 : -1;
      }
      const equalKeys = keyID === keyOrder;
      const calculateNewQuery = function calculateNewQuery() {
        const queryEnd = {};
        // ejm: { $lt: 55, $gt: 55 }
        const middleRangeQueryOrder = {};
        const queryOrs = [];
        const queryAnds = [];
        const keyOrderMax = queryParams.keyOrderMax;
        const keyOrderSince = queryParams.keyOrderSince;

        if (!_lodash2.default.isNil(keyOrderSince)) {
          // high range
          // ejm: { id: {$lt: sinceId}, count: 55 }
          const equalOrderSince = {};
          // ejm: {$lt: sinceId}
          const querySinceId = {};
          querySinceId[lsThanE] = queryParams.sinceId;
          if (!_lodash2.default.isNil(queryParams.sinceIdExclusive)) {
            querySinceId[lsThan] = queryParams.sinceIdExclusive;
          }
          equalOrderSince[keyID] = querySinceId;
          if (!equalKeys) {
            _lodash2.default.set(equalOrderSince, keyOrder, keyOrderSince);
            // equalOrderSince[keyOrder] = keyOrderSince;
          }
          debug('calculateNewQuery querySinceId', querySinceId);
          if (keyOrderMax === keyOrderSince || equalKeys) {
            queryAnds.push(equalOrderSince);
          } else {
            queryOrs.push(equalOrderSince);
            // middle range
            // ejm: {$lt: 55}
            middleRangeQueryOrder[lsThan] = queryParams.keyOrderSince;
          }
        }
        if (!_lodash2.default.isNil(keyOrderMax)) {
          // ejm: { id: {$gt: sinceId}, count: 33 }
          const equalOrderMax = {};
          // ejm: {$lt: sinceId}
          const queryMaxId = {};
          queryMaxId[gsThan] = queryParams.maxId;
          equalOrderMax[keyID] = queryMaxId;
          if (!equalKeys) {
            _lodash2.default.set(equalOrderMax, keyOrder, keyOrderMax);
            // equalOrderMax[keyOrder] = keyOrderMax;
          }
          debug('calculateNewQuery queryMaxId', queryMaxId);
          if (keyOrderMax === keyOrderSince || equalKeys) {
            queryAnds.push(equalOrderMax);
          } else {
            queryOrs.push(equalOrderMax);
            // middle range
            // ejm: {$gt: 33 }
            middleRangeQueryOrder[gsThan] = queryParams.keyOrderMax;
          }
        }
        if (!_lodash2.default.isEmpty(middleRangeQueryOrder)) {
          const queryOrderMiddle = {};
          _lodash2.default.set(queryOrderMiddle, keyOrder, middleRangeQueryOrder);
          // queryOrderMiddle[keyOrder] = middleRangeQueryOrder;
          queryOrs.push(queryOrderMiddle);
        }
        if (queryOrs.length) {
          queryAnds.push({
            $or: queryOrs
          });
        }
        if (!_lodash2.default.isEmpty(where)) {
          queryAnds.push(where);
        }
        if (queryAnds.length) {
          queryEnd.$and = queryAnds;
        }
        debug('calculateNewQuery', JSON.stringify(queryEnd));
        return queryEnd;
      };
      /**
       * find with query and map it
       * @param limitFind
       * @return {*}
       */
      const findWithLimit = (() => {
        var _ref4 = _asyncToGenerator(function* (limitFind, pageFind) {
          const queryObj = calculateNewQuery();
          debug('will findWithLimit', { where: queryObj, limit: limitFind, select: select });
          let query = _this.find(queryObj, select).sort(sort);
          if (limitFind) {
            query = query.limit(limitFind);
            if (pageFind) {
              query = query.skip(limitFind * pageFind);
            }
          }

          const objectsFirstFound = yield query.exec();
          let mappedObjects;
          // map the objects if there is a map
          if (map) {
            mappedObjects = yield _bluebird2.default.resolve(objectsFirstFound).map(map);
          } else {
            mappedObjects = objectsFirstFound;
          }
          return mappedObjects;
        });

        return function findWithLimit(_x3, _x4) {
          return _ref4.apply(this, arguments);
        };
      })();

      let objects = [];
      let limitObjects = parseInt(limit, 10) || 1;

      // FILTER
      if (filter) {
        let objToFilter = yield findWithLimit(limit, page);
        const objectsFoundFirst = objToFilter.length;
        if (objectsFoundFirst < limitObjects) {
          limitObjects = objectsFoundFirst;
        }
        let iterationCount = 0;
        // loop once to apply the filter
        do {
          debugData(`iteration ${iterationCount}, data`, objToFilter);
          // filter objects found that has not been filtered
          const objectsFiltered = yield _bluebird2.default.resolve(objToFilter).filter(filter);

          debugData(`iteration ${iterationCount}, data filtered`, objectsFiltered);
          // add filtered objects to final array
          objects = objects.concat(objectsFiltered);

          // set the limit to get the missing objects filtered
          limitObjects -= objectsFiltered.length;
          debug(`filtered ${limitObjects} element(s)`);
          if (limitObjects <= 0) {
            break;
          }
          const lastIndex = objToFilter.length - 1;
          const lastOrderValue = _lodash2.default.get(objToFilter[lastIndex], keyOrder);
          const lastOrderID = objToFilter[lastIndex][keyID];
          // set the cursor to search AFTER the last found
          queryParams.sinceIdExclusive = lastOrderID;
          queryParams.keyOrderSince = lastOrderValue;
          // get the new objects from the model list
          objToFilter = yield findWithLimit(limitObjects);

          debug(`${objToFilter.length} element(s) to replace with filter`);
          // while the limit has items to get and the found objects to fetch and filter
          iterationCount += 1;
        } while (limitObjects > 0 && objToFilter.length > 0);
      } else {
        // if there is no filter set objects found
        objects = yield findWithLimit(limit, page);
      }

      let nextCursor;

      if (objects.length) {
        debug('objects has length', objects.length);
        const lastItem = objects[objects.length - 1];
        queryParams.sinceId = lastItem[keyID];
        queryParams.keyOrderSince = _lodash2.default.get(lastItem, keyOrder);
        const findNextWithSameOrder = calculateNewQuery();

        debug('find nextCursor with', { where: findNextWithSameOrder, select: keyID });
        const nextObject = yield this.findOne(findNextWithSameOrder, keyID).sort(sort).skip(1);

        debug('found on nextObject', nextObject);
        if (!_lodash2.default.isNil(nextObject)) {
          nextCursor = nextObject[keyID];
          debug('nextCursor found', nextCursor);
        } else {
          debug('nextCursor no found');
        }
      }

      const objectReturn = {
        objects: objects,
        nextCursor: nextCursor
      };
      return objectReturn;
    });

    function paginate() {
      return _ref2.apply(this, arguments);
    }

    return paginate;
  })();

  if (name) {
    schema.statics[name] = paginate;
  } else {
    schema.statics.paginate = paginate;
  }
}
//# sourceMappingURL=Pagination.js.map